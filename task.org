* DONE Add kernel code/data segment 
CLOSED: [2015-09-29 Tue 16:05]
* DONE Add userspace code/data segment
CLOSED: [2015-09-29 Tue 16:05]
* DONE Add custom code/data segments (i.e. overlapping segments)
CLOSED: [2015-09-29 Tue 16:05]
* DONE Implement User Space (from ring 0 to ring 3)
CLOSED: [2015-09-29 Tue 16:04]
** DONE Create a call gate for userspace code to call into kernel space
CLOSED: [2015-10-08 Thu 18:29]
* DONE Implmenet system call (from ring 3 to ring 0)
CLOSED: [2015-10-01 Thu 16:23]
** DONE Use *sysenter* instruction properly
CLOSED: [2015-09-29 Tue 18:22]
Must setup in ring 0 the system call entry before getting into ring 3.
Otherwise, *wrmsr* and *rdmsr* don't work.
** DONE Use *sysexit* instruction properly
CLOSED: [2015-09-29 Tue 18:22]
We must push stack pointer to ecx, return address to edx for it to work properly
before calling *sysenter*
** DONE Make writing on scree properly after entering userspace
CLOSED: [2015-09-30 Wed 13:47]
Things to remember:
- After protected mode is entered, everything is accessed via segments.
- As a result, when switching between userspace and kernel space, we must use
  appropriate segments, otherwise even registers may hold correct address, wrong
  address is still accessed.
- Better define segment descriptor for specific memory mapping, i.e. video memory.
- EIP is relative to segment.

ClrScr32 works properly by using segment. Putch32 works properly by using
segment.

Learning how to create and manipulate properly is important.
* DONE Reorganize source code
CLOSED: [2015-10-01 Thu 16:24]
* DONE Create C/C++ Runtime Library (CRT) and Hardware Abstraction Layer (HAL)
CLOSED: [2015-10-05 Mon 18:28]
** DONE Construct a ctype.h
CLOSED: [2015-10-05 Mon 18:28]
- Need to understand the array ctype[] is holding type of character in ASCII,
  not the characters itself. We check the character types by indexed into the
  array.

- Construct convenient routines for character/string manipulation.
** DONE Construct macro to process variable number of arguments
CLOSED: [2015-10-05 Mon 18:28]
- Create va_list.h that creates a aliased type for char pointer to access
  memory locations of arguments of a function.
- Create VA_SIZE that calculates the size of an argument.
- Create VA_START that jump to the beginning of variable arguments based on the
  last concrete  argument in the function argument list and start the
  loop to process argument by argument.
- Create VA_END that terminate the loop.
- Create a va_arg to access current argument in argument list. We must supply a
  type for correct return the argument with appropriate type as well as
  advancing AP pointer to the correct position of the next argument.
* PROGRESS Interrupt
[[http://stackoverflow.com/questions/3425085/the-difference-between-call-gate-interrupt-gate-trap-gate][The difference between Call Gate, Interrupt Gate, Trap Gate?]]
** DONE Build an IDT for one interrupt and able to jump to it
CLOSED: [2015-10-05 Mon 18:29]
*** DONE Create a GDT entry for the interrupt
CLOSED: [2015-10-08 Thu 18:27]
*** DONE Credat a IDT entry for the interrupt
CLOSED: [2015-10-08 Thu 18:27]
** DONE After entering interupt routine, we should be able to return properly
CLOSED: [2015-10-06 Tue 16:01]
** DONE We should be able to define and use variables in the same file
CLOSED: [2015-10-06 Tue 18:11]
To do this, we must use *org* directive to tell the assembler where this file
starts from in memory, so it can generate precise memory location. Without *org*
directive, all we get is just an offset of a variable, from where it is to the start
of the file.
** DONE Call interrupts from userspace code
CLOSED: [2015-10-09 Fri 15:49]

_Exercises_:

- What happens when an interrupt generated from userspace but the corresponding
  IDT of the ISR only has DPL = 00b?

- What happens when an interrupt generated from userspace but the corresponding
  GDT of the ISR only has DPL = 00b?
**** DONE Make ISR able to access userspace data, so that it can retrieve function arguments
CLOSED: [2015-10-09 Fri 15:41]
Since everything is accessed via segment, if we want to access userspace data
universally everywhere with absolute addressing, make userspace data segment has
base 0 with offset 0.
** PROGRESS Find a way to calculate address of interrupt service routines, not hard code addressses
*** DONE Create an array of 256 quad word, used as IDT
CLOSED: [2015-10-15 Thu 15:07]
Code:

idt: times 256 dq 0 ; 256 entries
*** DONE Create an array of function pointers to interrupt service routines
CLOSED: [2015-10-15 Thu 15:07]
*** DONE Create a NASM macro for each interrupt that push error code and IRQ number on stack 
CLOSED: [2015-10-15 Thu 15:05]
It's the two macros *isr_error_code* and *isr_no_error_code*.
*** DONE Create a NASM macro for each interrupt to register itself to IDT
CLOSED: [2015-10-15 Thu 15:08]
It's the macro *install_isr*
*** DONE Create a sample interrupt handler for an IRQ i.e. IRQ 0
CLOSED: [2015-10-15 Thu 15:06]
It's _isr0 in my code that does actual work.
*** DONE Select an appropriate ISR service rountines from array of ISRs and call it
CLOSED: [2015-10-15 Thu 16:05]
The array is:

isrs:
  dd _isr0

From the starting address of *isrs*, we calculate offset into appropriate
function pointer of an IRQ number. For example, offset to IRQ 5 is calculated
as:

<address of isrs> + 4 * IRQ_Number

** PROGRESS Program the 8256A PIC
http://stanislavs.org/helppc/8259.html
*** Get it working
** Handlde division by 0 interrupt
Current problem: it always returns to erroneous div instruction.
