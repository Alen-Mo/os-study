* Learning objectives
* What is a computer?
- A computer combines a processor, random access memory (RAM), read only memory
(ROM), and input/output (I/O) ports. 

- A microprocessor is a small processor. A microcomputer is a small computer that
includes a processor, memory and I/O devices. A microcontroller is a single chip
computer.

- Current implementation: an electrical circuit that implements computation.

- Future implementation: Biological computer, quantum computer.
* Computer implementation: Von Neumman architecture
(Use the PPT slide from Computational Structure Part 2).
* How can software controls hardware?
- Through ardware-software interface: ASM.

- Each ASM instruction is implemented in hardware. A collection of ASM
  instructions is called ISA - Instruction Set Architecture. ISA is a contract
  between software and hardware.

- ISA allows programmers to control the CPU and other devices in a computer to
  create computer programs.

- Program is loaded on memory, CPU fetches and execute instruction by
  instruction until the end. It works for small computer i.e. microcontroller.

* The need for an operating system
- When resources in a computer system (CPU, memory, hard drive...) became big
  and more complicated, it's tedious to manually manage all the resources.

- For example: Imagine we have to manually load programs on a computer with 3GB
  RAM. We would have to load programs at various fix addresses, and for each
  program a size must be manually calculated to avoid wasting memory resource,
  and enough for programs to not overriding each other.

- A software is needed to automatically manage all these tasks. This software is
  called *Operating System*.

* Jobs of an operating system
Manage hardware resources automatically and efficiently. The two most basic
tasks that an OS need to perform

- Manage CPU: allows programs to share hardware resources for multitasking.
- Manage memory: allocates enough storage for a program to function.

The above two resources are essential in a Von Neumman archtecture, and any OS
should be good at the above tasks. Other responsibilities include:

- Filesystem for managing various types of data.
- Manage other hardware devices i.e. hard drive, printer, graphic devices...
- Security: OS rings, kernel/user space, different address spaces for different processes.
- A framework for managing hardware resources i.e. it should be easy to extend
  OS code to talk to new hardware.

Our OS will be a simple OS that implements two most basic tasks: manage CPU and memory.

* Features of our educational OS
Bootloader
- Stage 1
- Stage 2

Kernel
- Kernel space
- User space
- Interrupt handler
- Basic graphic management.
- PIC Programming.
- Keyboard programming.

We will learn a great deal about x86 architecture through writing this OS.

* Tools: Build and install Bochs
** nasm
Add option -l for listing label addresses.
** bochs
Another trick to simply move the label address to one of a register and for it
to be stored in Bochs log.
** bochsdbg
* Bootloader
** How a typical computer boots
** General algorithm
- Before booting: write the bootloader to MBR (first 512 bytes). The bootloader
  must fill 512 bytes entirely, with the last 2 bytes a device signature i.e. a
  flobby disk signature 0xAA55.

- When computer starts:
  + Load first 512 bytes (MBR) and execute code in there.
  + Clear segment registers.
  + Print some text (optinal).
  + Load more code in futher sectors of the disk to execute.
** How to create a virtual flobby disk
Using dd.
** How to write a binary file to first sector (MBR)
Using dd.
** How to write to any sector
Using dd with seek option.
** Read a sector with BIOS interrupt and load it on an address
Use BIOS routine for reading/writing disk sectors and load in a specific
address. In real mode, we must not exceed 16 bits or else it will wrap around.
* Rings
** Switching rings
* System architecture
- All circuits are made either combination or sequential.
- Programmers communicate with hardware through writing to ports (physical pins)
  or writing to registers.
- Controllers are just programmable hardware. CPU is just another form of controller.
** The 80x86 Registers
*** Segment registers
*** Index registers
*** PC register
*** Special purpose registers
** System Orginazation
- Von Neumann: data and instructions share memory. Instructions are a form of data.
- The CPU communicates with the Memory Controller to retrieve data and instructions.
** The System Bus
*** Data bus
*** Address bus
*** Control bus
** Real Mode Memory Map
** How an instruction executes
- Using the instruction register (also call Program Counter) to point to the
  address of the next instruction.
** Software Ports
All I/O Ports are mapped to a given memory location. This allows us to use the
*IN* and *OUT* instructions. I/O ports are just physical pins anyway.
* Protected mode
- Designed to increase the stability of the systems.
- Has hardware support for Virtual Memory and Task State Switching (TSS)
- Hardware support for interrupting programs and executing another
- 4 Operating Modes: Ring 0, Ring 1, Ring 2, Ring 3
- Access to 32 bit registers
- Access to up to 4 GB of memory
* A20 line
- To maintain backward compatible with older x86 processor, A20 is disabled to
  prevent accessing memory beyond 1MB, so the memory address can wrap around.
  
- For example, if we try to access address beyond 0x10000 in real mode, like
  0x10047, the address becomes 0x00047 after we load it into a register.
* Global Descriptor Table
- Provide parameters for code/data segments i.e. where each segment starts.
- Once getting into Protected Mode, jump must use the selectors defined by the
  table. Absolute address has no effect.
- Direction Bit/Conforming Bit is very important for defining a call gate.
http://wiki.osdev.org/GDT
** Exercises
- Load and execute the kernel at 0x1000 in protected mode.
- Load and execute the kernel at 0x10000 in protected mode.
- Load and execute the kernel at 0x20000 in protected mode.
- Load and execute the kernel at 0x100F0 in protected mode.
- Load and execute the kernel at 0x10FF0 in protected mode.
- Load and execute the kernel at 0x10FFF in protected mode.
* Basic VGA programming
- Write a character at position (5,5).
- Write a character at position (10,10).
- Write a string at position (5,5).
- Write two string at position (5,5) and (5,6) by moving the cursor.
* Getting into User Space
- Kernel cannot jump/call into code in userspace directly. Fault occurs when
  trying ot do so. We can only jump from lower privilege code to higher (i.e.
  from ring 3 to ring 0).
- Must execute IRET instruction. We must push appropriate data on the stack for
  the instruction to use. This is important.
- Must Define userspace segments (code and data) in GDT, so IRET can jump properly

