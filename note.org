* Learning objectives
* What is a computer?
- A computer combines a processor, random access memory (RAM), read only memory
(ROM), and input/output (I/O) ports. 

- A microprocessor is a small processor. A microcomputer is a small computer that
includes a processor, memory and I/O devices. A microcontroller is a single chip
computer.

- Current implementation: an electrical circuit that implements computation.

- Future implementation: Biological computer, quantum computer.
* Computer implementation: Von Neumman architecture
(Use the PPT slide from Computational Structure Part 2).
* How can software controls hardware?
- Through ardware-software interface: ASM.

- Each ASM instruction is implemented in hardware. A collection of ASM
  instructions is called ISA - Instruction Set Architecture. ISA is a contract
  between software and hardware.

- ISA allows programmers to control the CPU and other devices in a computer to
  create computer programs.

- Program is loaded on memory, CPU fetches and execute instruction by
  instruction until the end. It works for small computer i.e. microcontroller.

* The need for an operating system
- When resources in a computer system (CPU, memory, hard drive...) became big
  and more complicated, it's tedious to manually manage all the resources.

- For example: Imagine we have to manually load programs on a computer with 3GB
  RAM. We would have to load programs at various fix addresses, and for each
  program a size must be manually calculated to avoid wasting memory resource,
  and enough for programs to not overriding each other.

- A software is needed to automatically manage all these tasks. This software is
  called *Operating System*.

* Jobs of an operating system
Manage hardware resources automatically and efficiently. The two most basic
tasks that an OS need to perform

- Manage CPU: allows programs to share hardware resources for multitasking.
- Manage memory: allocates enough storage for a program to function.

The above two resources are essential in a Von Neumman archtecture, and any OS
should be good at the above tasks. Other responsibilities include:

- Filesystem for managing various types of data.
- Manage other hardware devices i.e. hard drive, printer, graphic devices...
- Security: OS rings, kernel/user space, different address spaces for different processes.
- A framework for managing hardware resources i.e. it should be easy to extend
  OS code to talk to new hardware.

Our OS will be a simple OS that implements two most basic tasks: manage CPU and memory.

* What we will implement in our educational OS
Bootloader
- Stage 1: rudimentary setup for next stage
- Stage 2: setup to prepare for procted mode environment.

Kernel
- Kernel space
- User space
- Interrupt handler
- Basic graphic management.
- PIC Programming.
- Keyboard programming.

We will learn a great deal about x86 architecture through writing this OS.

* Tools
** A working Linux environment
** nasm
- Homepage: http://www.nasm.us/
- Install with a package manager or compile from source.
** bochs
- Homepage: http://bochs.sourceforge.net/
- Download: http://sourceforge.net/projects/bochs/
- Compile from source to get both =bochs= and =bochsdbg=.
- To build:

./configure --enable-all-optimizations --enable-disasm --enable-logging
  --with-sdl --with-x --with-x11
make
sudo make install

- Rebuilt again, this time with option =--enable-debugger== added. This time,
  don't run =make install=, but rename the built =bochs= binary to =bochsdbg=
  because this time it is built as a debugger for exammining each asm
  instruction.

- Copy the =bochs-dbg= binary to somewhere in your $PATH like =/usr/local/bin=.
*** Bochs config
** dd 
** 
* Bootloader
** Boot process
- When the power button press, the Power Supply Unit (PSU) sends a signal to
  motherboard.

- Motehrboard reroutes this signal back to PSU to inform about its status. If a
  0 is received, meaning the motherboard is dead; otherwise, the motherboard is
  alive and PSU starts supplying power to the rest of the system.

- The PSU then sends a signal, called the "power_good" signal into the
  motherboard timer. When the timer receives this signal, it stops forcing a
  reset signal to the CPU and the CPU begins processing instructions
** Boot process (BIOS)
BIOS refers to the firmware instructions that are located on the BIOS ROM

- The very first instruction performed by a CPU is to read the contents of a
  specific memory address that is preprogrammed into the CPU. In the case of x86
  based processors, this address is *FFFF:0000h*. This is the last 16 bytes of
  memory at the end of the first megabyte of memory, store a jump instruction
  (JMP) to jump to BIOS ROM code.

- The BIOS begins initializing a process called POST (Power On Self Test)

- The POST then tests to insure there is good amount of power being supplied,
  the devices installed (such as keyboard, mouse, USB, serial ports, etc.), and
  insures the memory is good (By testing for memory curruption).

- After the test is done, the BIOS searches for an operating system stored in
  the first 512 bytes of a bootable device, like a flobby disk or a hard drive.

** Boot Process (BIOS) - continued
- Based on the boot order that you set in the BIOS Setup, the BIOS will execute
  Interrupt (INT) *0x19* to attempt to find a bootable device.

- If no bootable device is found (*INT 0x19* returns), the BIOS goes on to the
  next device listed in the boot order. If there is no more devices, it will
  print an error simular to "No Operating System found" and halt the system.

- If a bootloader is found (in the first 512 bytes of a any device), The BIOS
  then load the bootloader at location *0x7C00h* and start executing bootloader
  code.

For more detailed steps: http://www.bioscentral.com/misc/biosbasics.htm

** Anatomy of a disk

[[./hdd.gif][hdd]]

** Algorithm
  + Clear segment registers.
  + Print some text (optinal).
  + Load more code in futher sectors of the disk to execute.
  + Fill the remaining of 512 bytes with 0, with the last 2 bytes a device
    signature i.e. a flobby disk signature 0xAA55.
** A Very simple bootloader
;*********************************************
;	Boot1.asm
;		- A Simple Bootloader
;
;	Operating Systems Development Tutorial
;*********************************************
 
org		0x7c00				; We are loaded by BIOS at 0x7C00
 
bits	16					; We are still in 16 bit Real Mode
 
Start:
 ; we will fill more code here later

	cli					; Clear all Interrupts
	hlt					; halt the system
	
times 510 - ($-$$) db 0				; We have to be 512 bytes. Clear the rest of the bytes with 0
 
dw 0xAA55					; Boot Signiture

* Rings
** Switching rings
* System architecture
- All circuits are made either combination or sequential.
- Programmers communicate with hardware through writing to ports (physical pins)
  or writing to registers.
- Controllers are just programmable hardware. CPU is just another form of controller.
** The 80x86 Registers
*** Segment registers
*** Index registers
*** PC register
*** Special purpose registers
** System Orginazation
- Von Neumann: data and instructions share memory. Instructions are a form of data.
- The CPU communicates with the Memory Controller to retrieve data and instructions.
** The System Bus
*** Data bus
*** Address bus
*** Control bus
** Real Mode Memory Map
** How an instruction executes
- Using the instruction register (also call Program Counter) to point to the
  address of the next instruction.
** Software Ports
All I/O Ports are mapped to a given memory location. This allows us to use the
*IN* and *OUT* instructions. I/O ports are just physical pins anyway.
* Protected mode
- Designed to increase the stability of the systems.
- Has hardware support for Virtual Memory and Task State Switching (TSS)
- Hardware support for interrupting programs and executing another
- 4 Operating Modes: Ring 0, Ring 1, Ring 2, Ring 3
- Access to 32 bit registers
- Access to up to 4 GB of memory
* A20 line
- To maintain backward compatible with older x86 processor, A20 is disabled to
  prevent accessing memory beyond 1MB, so the memory address can wrap around.
  
- For example, if we try to access address beyond 0x10000 in real mode, like
  0x10047, the address becomes 0x00047 after we load it into a register.
* Global Descriptor Table
- Provide parameters for code/data segments i.e. where each segment starts.
- Once getting into Protected Mode, jump must use the selectors defined by the
  table. Absolute address has no effect.
- Direction Bit/Conforming Bit is very important for defining a call gate.
http://wiki.osdev.org/GDT
** Exercises
- Load and execute the kernel at 0x1000 in protected mode.
- Load and execute the kernel at 0x10000 in protected mode.
- Load and execute the kernel at 0x20000 in protected mode.
- Load and execute the kernel at 0x100F0 in protected mode.
- Load and execute the kernel at 0x10FF0 in protected mode.
- Load and execute the kernel at 0x10FFF in protected mode.
* Basic VGA programming
- Write a character at position (5,5).
- Write a character at position (10,10).
- Write a string at position (5,5).
- Write two string at position (5,5) and (5,6) by moving the cursor.
* Getting into User Space
- Kernel cannot jump/call into code in userspace directly. Fault occurs when
  trying ot do so. We can only jump from lower privilege code to higher (i.e.
  from ring 3 to ring 0).
- Must execute IRET instruction. We must push appropriate data on the stack for
  the instruction to use. This is important.
- Must Define userspace segments (code and data) in GDT, so IRET can jump properly

n
