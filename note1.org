#+TITLE: How to implement an Operating System from scratch
#+DATE: 2016 January  22
#+AUTHOR: Tu, Do
#+EMAIL: tu.h.do@dektech.com.au
#+OPTIONS: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:t p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+CREATOR: Emacs 24.5.1 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+startup: beamer
#+BEAMER_THEME: Frankfurt [height=9pt]
#+LaTeX_CLASS: beamer
#+BEAMER_FRAME_LEVEL: 1

* How to implement an Operating System from scratch
** Learning objectives
At the end of the course, we should be able to write an OS with:

*Bootloader*:
- Stage 1: rudimentary setup for next stage
- Stage 2: setup to prepare for protected mode environment.

*Kernel*:
- Kernel space
- User space
- Interrupt handler
- Basic graphic management.
- PIC Programming.
- Keyboard programming.
- DMA programming.

We will learn a great deal about x86 architecture through writing this OS. Once
you master the concepts, learning mainstream OS development like Linux will be
much easier.

** What is a computer?
- A *computer* combines a processor, random access memory (RAM), read only
  memory (ROM), and input/output (I/O) ports.

- A *microprocessor* is a small processor. A microcomputer is a small computer
  that includes a processor, memory and I/O devices.

- A *micro-controller* is a single chip computer.

- Current implementation: an electrical circuit that implements computation.

- Future implementation: Biological computer, quantum computer.

** Types of Computers
- Computers can be divided into two types: single-purpose and general-purpose.

- _Single-purpose computer_ is a computer that is built at *hardware level* for
  specific tasks. For example, dedicated encoders/decoders , timer,
  image/video/sound processors... These computers are created through direct
  circuit designed called *Application-Specific Integrated Circuit* (=ASIC=) or
  *FPGA*, a programmable hardrware to emulate other hardware.

- _General-purpose computer_: can be programmed (without modifying the hardware
  like ASIC or FPGA) to emulate various features of single-purpose computers.

  - Current general-purpose computer is implemented based on Von Neuman architecture
** Note about single-purpose computer
- Another type of single-purpose computer is a general-purpose computer with
  very limited resource that only able to perform one or a few tasks.

- Even though these computers are used for a single purpose, it can be
  programmed to perform different tasks, depends on the programmers.

** Computer implementation: Von Neumman architecture
Named after John Von Neumman.

[[./von_neuman_computer.gif][von_neumman]]

- *Central processing unit*: Performs operations on values in registers & memory.
- *Main memory*: Array of W words of N bits each.
- *Input/output devices* to communicate with the outside world.

** How a Von Neumman computer works
- Fetch: Instruction is retrieved from working memory (RAM).
- Decode: CPU identifies which instruction has been fetched.
- Execute: Run the instruction as implemented in processor hardware.
** Examples of a computer
[[./macbook.jpeg][macbook]]

[[./stm-microcontroller.jpeg][stm-microcontroller]]

[[./pic.jpeg][pic]]
** How can software controls hardware?
- Through hardware-software interface: *Assembly language*.

- Each ASM instruction is implemented in hardware as a series of bits. Each ASM
  instruction has a different bit pattern.

- A collection of ASM instructions is called ISA - Instruction Set Architecture.
  ISA is a contract between software and hardware.

- ISA allows programmers to control the CPU and other devices in a computer to
  create computer programs.

- Program is loaded on memory, CPU fetches and execute instruction by
  instruction until the end. It works for small computer i.e. micro-controller.
** Important remark
- *You can implement all software functions in hardware, and you can also
  possible to implement all hardware functions in software.*

- Complex instructions can be built at hardware level, like all the assembly
  instructions of a CPU. See [[http://sgate.emt.bme.hu/patai/publications/z80guide/part4.html][this page]] for details implementaion details.

- However, complex instructions can be created from simpler instructions, if the
  CPU does not support such instructions. To mulitple, simply use *mul*
  instruction.

  #+BEGIN_SRC asm
    mov edx, 1024
    mul edx     ; multiply edx with eax
  #+END_SRC

** Example

- Z80 CPU has no *mul* intruction for multiplication. Programmers have to create
  a routine using simpler built-in instruction.

- x86_64 and almost all modern CPU provide *mul* instruction. 

** The need for an operating system
- When resources in a computer system (CPU, memory, hard drive...) became big
  and more complicated, it's tedious to manually manage all the resources.

- For example: Imagine we have to manually load programs on a computer with 3GB
  RAM. We would have to load programs at various fix addresses, and for each
  program a size must be manually calculated to avoid wasting memory resource,
  and enough for programs to not overriding each other.

- A software is needed to automatically manage all these tasks. This software is
  called *Operating System*.

** Jobs of an operating system
Manage hardware resources automatically and efficiently. The two most basic
tasks that an OS need to perform

- Manage CPU: allows programs to share hardware resources for multitasking.
- Manage memory: allocates enough storage for a program to function.

The above two resources are essential in a Von Neumman archtecture, and any OS
should be good at the above tasks. Other responsibilities include:

- Filesystem for managing various types of data.
- Manage other hardware devices i.e. hard drive, printer, graphic devices...
- Security: OS rings, kernel/user space, different address spaces for different processes.
- A framework for managing hardware resources i.e. it should be easy to extend
  OS code to talk to new hardware.

Our OS will be a simple OS that implements two most basic tasks: manage CPU and memory.

** Tools
*** A working Linux environment
- Linux has many utilities that make development easier i.e. =make=, =dd=...

- It is easier to control development process with Linux, because you are
  expected to do so. This is beneficial for our educational purpose.

*** nasm
- Homepage: http://www.nasm.us/
- Install with a package manager or compile from source.

** Tools (continued)
*** bochs
- Homepage: http://bochs.sourceforge.net/
- Download: http://sourceforge.net/projects/bochs/
- Compile from source to get both =bochs= and =bochsdbg=.

*** dd 
We use =dd= to create a flobby disk image that Bochs can use to boot our OS.

To create a disk image::

#+BEGIN_SRC sh
  dd if=/dev/zero of=disk.dsk bs=512 count=54
#+END_SRC

=if=: input file to write.
=of=: output disk image.
=bs=: block devices read by block; this parameter specifies block size that
a block device can read at a time
=count=: number of block a disk can have
** Boot process
*** Pre BIOS
- When the power button press, the *Power Supply Unit* (=PSU=) sends a signal to
  motherboard.

- Motherboard reroutes this signal back to PSU to inform about its status. If a
  0 is received, meaning the motherboard is dead; otherwise, the motherboard is
  alive and PSU starts supplying power to the rest of the system.

- The PSU then sends a signal, called the *power_good* signal into the
  motherboard timer. When the timer receives this signal, it stops forcing a
  reset signal to the CPU and the CPU begins processing instructions.
*** BIOS
BIOS refers to the firmware instructions that are located on the *BIOS ROM*

- The very first instruction performed by a CPU is to read the contents of a
  specific memory address that is preprogrammed into the CPU. In the case of x86
  based processors, this address is *FFFF:0000h*. This is the *last 16 bytes of
  memory at the end of the first megabyte of memory*, store a jump instruction
  (JMP) to jump to BIOS ROM code.

- The BIOS begins initializing a process called *Power On Self Test* (=POST=)

- The POST then tests to insure there is good amount of power being supplied,
  the devices installed (such as keyboard, mouse, USB, serial ports, etc.), and
  insures the memory is good (By testing for memory curruption).

- After the test is done, the BIOS searches for an operating system stored in
  the first 512 bytes of a bootable device, like a flobby disk or a hard drive.

*** BIOS - continued
- Based on the boot order that you set in the BIOS Setup, the BIOS will execute
  Interrupt (INT) *0x19* to attempt to find a bootable device.

- If no bootable device is found (*INT 0x19* returns), the BIOS goes on to the
  next device listed in the boot order. If there is no more devices, it will
  print an error simular to "No Operating System found" and halt the system.

- If a bootloader is found (in the first 512 bytes of a any device), The BIOS
  then load the bootloader at location *0x7C00h* and start executing bootloader
  code. Address to jump to, like *0x7c00h*, is defined by the BIOS.

For more detailed steps: http://www.bioscentral.com/misc/biosbasics.htm
For more infomation about *0x7c00h*: http://www.glamenv-septzen.net/en/view/6

*** Anatomy of a disk

[[./hdd.gif][hdd]]

- *Sector*: a group of 512 bytes. So, Sector 1 represents the first 512 bytes of a disk.
- *Head*: the side of the disk. Head 0 is the front side, Head 1 is the back side.
  Most disks only have 1 side, hence only 1 head ("Head 1")
- *Track*: a collection of sector. There are 18 sectors per track on flobby disk.
- *Cylinder*: a collection of same tracks on different platters.

*** Algorithm
- Clear segment registers.
- Print some text (optinal).
- Load more code in futher sectors of the disk to execute.
- Fill the remaining of 512 bytes with 0, with the last 2 bytes a device
  signature i.e. a flobby disk signature 0xAA55.
*** A Very simple bootloader
;*********************************************
;	Boot1.asm
;		- A Simple Bootloader
;
;	Operating Systems Development Tutorial
;*********************************************
 
org		0x7c00				; We are loaded by BIOS at 0x7C00
 
bits	16					; We are still in 16 bit Real Mode
 
Start:
 ; we will fill more code here later

	cli					; Clear all Interrupts
	hlt					; halt the system
	
times 510 - ($-$$) db 0				; We have to be 512 bytes. Clear the rest of the bytes with 0
 
dw 0xAA55					; Boot Signiture
